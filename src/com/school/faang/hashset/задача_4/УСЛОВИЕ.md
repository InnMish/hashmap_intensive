## Управление ролями в канале Telegram

Представь, что ты — разработчик в команде Telegram. Тебе поручили создать систему для управления ролями участников в больших каналах.

В канале не может быть двух одинаковых пользователей (проблема уникальности), и у каждого пользователя должна быть своя роль: `"админ"`, `"модератор"` или `"участник"`.

Система должна уметь мгновенно отвечать на вопросы:
- Состоит ли пользователь в канале?
- Какая у него роль?

Использовать только `HashSet` или только `HashMap` здесь неудобно.  
А вот их **комбинация** — идеальное решение:

- `HashSet` будет хранить всех уникальных участников для быстрой проверки членства.
- `HashMap` будет связывать ID участника с его ролью.

## Что нужно сделать

1. Создай класс `ChannelManager`.

2. Добавь два приватных поля:
   - `private HashSet<String> members` — для хранения уникальных ID всех участников.
   - `private HashMap<String, String> memberRoles` — для хранения пар `"ID участника" -> "его роль"`.

3. Инициализируй обе коллекции в конструкторе.

4. Реализуй метод `void addUser(String userId, String role)`, который добавляет пользователя в обе коллекции.

5. Реализуй метод `void removeUser(String userId)`, который удаляет пользователя из обеих коллекций.

6. Реализуй метод `String getRole(String userId)`, который возвращает роль участника по ID.
   - Если пользователя нет в `memberRoles`, метод должен вернуть строку:  
     `"Не является участником"`.

7. Реализуй метод `boolean hasUser(String userId)`, который проверяет наличие пользователя в канале, используя `members`.

8. В методе `main` продемонстрируй работу:
   - Создай экземпляр `ChannelManager`.
   - Добавь несколько пользователей с разными ролями:  
     `addUser("id123", "админ")`  
     `addUser("id456", "модератор")`  
     `addUser("id789", "участник")`
   - Проверь наличие одного пользователя с помощью `hasUser`.
   - Получи и выведи роль другого пользователя через `getRole`.
   - Удали одного участника с помощью `removeUser`.
   - Проверь, что он больше не числится участником и его роль недоступна.

## Почему задача полезна

Эта задача показывает силу комбинации структур данных.

Используя их вместе, ты строишь быструю и логичную систему.  
Вместо медленного перебора всех объектов ты получаешь доступ к данным **за O(1)**.

Это критически важно для отзывчивости интерфейсов в системах с миллионами пользователей.