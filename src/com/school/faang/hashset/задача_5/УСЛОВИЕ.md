## Управление лобби в онлайн-игре

Ты — разработчик в студии, создающей онлайн-шутер, вроде CS.  
Перед матчем игроки собираются в игровом лобби. Лобби должно обеспечивать:

- уникальность игроков (никто не может зайти дважды),
- порядок присоединения (в каком порядке игроки зашли),
- возможность быстро проверять, есть ли игрок в лобби,
- удаление игроков.

Для этого ты создашь отдельный класс `Player`, в котором будет храниться никнейм и статус игрока.

## Что нужно сделать

1. Создай класс `Player` с полями:
   - `private String nickname;`
   - `private String status;` (по умолчанию `"Не готов"`)

  Подумай, что нужно сделать, чтобы два игрока считались одинаковыми, если у них одинаковый `nickname`. Статус учитывать не нужно!

2. Создай класс `GameLobby`.

3. Добавь два приватных поля:
   - `private КОЛЛЕКЦИЯ1<Player> players;`
   - `private КОЛЛЕКЦИЯ2<Player> playerJoinOrder;`
   
Подумай, какие коллекции подойдет для решения задач выше?

4. Инициализируй оба поля в конструкторе.

5. Реализуй метод `void addPlayer(String nickname)`:
   - Если игрок с таким никнеймом уже есть в `players`, ничего не делай.
   - Иначе:
      - создай нового `Player` со статусом `"Не готов"`,
      - и сделай так, чтобы он зашел в лобби.

6. Реализуй метод `void removePlayer(String nickname)`:
   - Удаляет игрока из обеих коллекций

7. Реализуй метод `boolean hasPlayer(String nickname)`, который проверяет наличие игрока в лобби.

8. Реализуй метод `void displayPlayers()`, который выводит список игроков в порядке подключения с их текущими статусами.

Обрати внимание, что тебе нужно использовать преимущество HashSet! Убедись, что ты делаешь это, а не ищешь нужных игроков вручную.

## Демонстрация (в `main`):

- Создай `GameLobby`.
- Добавь нескольких игроков.
- Попробуй добавить одного из них повторно — убедись, что дубликат не появился.
- Удали одного игрока.
- Выведи список игроков до и после удаления.

## Почему задача полезна

Эта задача показывает, как добиться одновременно:

- **уникальности** 
- **сохранения порядка** 

Это пример того, как строить лёгкую, но масштабируемую систему без лишних структур, используя преимущества объектно-ориентированного подхода.